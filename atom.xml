<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Token.github.io</id>
    <title>tang1201blog</title>
    <updated>2020-04-28T09:29:46.921Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Token.github.io"/>
    <link rel="self" href="https://Token.github.io/atom.xml"/>
    <subtitle>分享也是一种学习</subtitle>
    <logo>https://Token.github.io/images/avatar.png</logo>
    <icon>https://Token.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, tang1201blog</rights>
    <entry>
        <title type="html"><![CDATA[# **python语法**]]></title>
        <id>https://Token.github.io/post/python-yu-fa/</id>
        <link href="https://Token.github.io/post/python-yu-fa/">
        </link>
        <updated>2020-04-28T08:18:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1变量以及数据类型"><strong>1.变量以及数据类型</strong></h2>
<h3 id="数据类型">数据类型</h3>
<p>Numbers 数字：</p>
<p>int（有符号整型）long（长整型[也可以表示八进制和十六进制]，python3里已经废弃了）float（浮点型） complex（复数）</p>
<p>布尔类型 bool ：    Ture          False</p>
<p>String（字符串）</p>
<p>空值	None</p>
<p>List（列表）——&gt;shuzu----[]</p>
<p>Tuple（元祖）——&gt;()</p>
<p>Dictionary（字典）——&gt;{}</p>
<p>集合类型</p>
<h3 id="进制转换"><em>进制转换：</em></h3>
<p>使用代码进行进制转换：详见下列代码</p>
<pre><code class="language-python">a = 12
print(bin(a))  #0b1100
print(oct(a))  #0o14
print(hex(a))  #0xc
</code></pre>
<p>使用bin内置函数可以将数字转换成二进制</p>
<p>使用oct内置函数可以将数字转换成八进制</p>
<p>使用hex内置函数可以将数字转换成十六进制</p>
<p>在python里，变量是没有数据类型的，我们所说变量的数据类型，其实是变量对应的值的数据类型，不需要定义变量，直接是动态的，会随时修改的</p>
<h3 id="标识符关键字"><strong>标识符关键字</strong></h3>
<h4 id="标识符"><strong>标识符：</strong></h4>
<p>变量，模块名，函数名，类名</p>
<h4 id="标识符的命名规则"><strong>标识符的命名规则：</strong></h4>
<ol>
<li>
<p>由数字、字母和_下划线组成，不能以数字开头</p>
</li>
<li>
<p>严格区分大小写（计算机编程里，一共52个英文字母，26大写+26小写）</p>
</li>
<li>
<p>不能使用关键字（在python语言里有特殊含义的单词）作为变量名</p>
</li>
</ol>
<h4 id="规范建议遵守遵守规范会显得专业并且代码易读"><strong>规范：建议遵守，遵守规范会显得专业，并且代码易读</strong></h4>
<ol>
<li>
<p>做到顾名思义</p>
</li>
<li>
<p>遵守一定的命名规范</p>
<ol>
<li>小驼峰命名法：第一个单词的首字母小写，以后每个单词的首字母都大写</li>
<li>大驼峰命名法：每个单词的首字母都大写</li>
<li>使用下划线连接</li>
</ol>
<p>在python里的变量、函数和模块名都使用下划线连接；</p>
<p>python里的类名使用大驼峰命名法</p>
</li>
</ol>
<h3 id="输出语句"><strong>输出语句</strong></h3>
<p>####　print</p>
<pre><code class="language-python">#输出
a = 32
b = 'hello'
c = True 
d = ['zjlun','zhansn']
print(type(a))
print(type(b))
print(type(c))
print(type(d))
print(type(3.14))
</code></pre>
<p>​	sep 参数用来表示输出时，每个值之间用哪种字符作为分隔。默认使用空格，修改方式如下</p>
<pre><code class="language-python">我 = '张三'
print(我)
print('hello','good','yes','hi')
print('hello','good','yes','hi',sep='+')
</code></pre>
<p>​	end 当执行完一个print语句以后，接下来要输出的字符。默认为\n表示换行，修改方式如下</p>
<pre><code class="language-python">print('hello','good','yes','hi',end = '\t')
print('hello','good','yes','hi',end = '————————————')
print('hello','good','yes','hi')
</code></pre>
<h3 id="输入"><strong>输入</strong></h3>
<h4 id="input">input</h4>
<p>input()      ==&gt;    括号里写提示信息</p>
<p>​	定义一个变量可以保存用户输入的内容，如下</p>
<pre><code class="language-python">#输入

input(&quot;请输入您的密码：&quot;)

password = input(&quot;请输入您的密码：&quot;)
print(password)
</code></pre>
<p>​	<em>注意：不管用户输入的是什么，变量保存保存的结果都是字符串</em></p>
<h3 id="类型转换"><strong>类型转换</strong></h3>
<p>将一个类型的数据转换为其他类型数据</p>
<pre><code class="language-python">age = input('请输入您的年龄：')
#print(age + 1)   error
#原因：input 接收到的用户输入都是 str 字符串类型
#在python里，如果字符串和数字做加法运算，会直接报错
#把字符串类型的变量 age 转换成为数字类型的 age
print(type(age))
#使用 int 内置类可以将其他类型的数据转换为整数
age = int(age) + 1
print(type(age))
#转换数据类型的原因：不同的数据类型进行运算时的运算规则是不一样的
</code></pre>
<pre><code class="language-python">#转化为整数
a = '31'
print(a) #输出31，但这个31是字符串类型
#如果字符串不是合法的数字，将字符串转换成int会直接报错
x = 'hello'
y = int(x)
print(y)

x = '1a2c'
y = int(x,16)#将字符串当做16进制数转换
#只能包含A-F

m = '12'
n = int(m,8)
print(n) # 10
</code></pre>
<pre><code class="language-python">#转化为浮点数
a = '12.34'
#使用内置float类可以将其他类型数据转换成为float浮点数
b = float(a)
print(b+1)

c = 101
print(float(c))

print(float('12'))#将字符串转换成浮点数     12
print(float(12))#将整型数字转换成浮点数     12
</code></pre>
<pre><code class="language-python">#转换成为字符串
#使用 str 内置类可以将其他类型数据转换成为字符串
a = 34
b = str(a)
print(a,b)# 34 34 前一个是int 后一个是字符串
</code></pre>
<h4 id="转换为布尔值"><strong>转换为布尔值</strong></h4>
<pre><code class="language-python">#使用bool内置类可以将其他数据类型转换成布尔值
print(bool(100))#将1数字100转换成布尔值    True
print(bool(-1))#True
print(bool(0))#False
#数字非零都是True

#字符串转布尔类型
print(bool('hello'))# True
print(bool('False'))#True
print(bool(''))#False
#空字符串 ''/&quot;&quot; 才能转换为False，其他字符串都是True

#None空数据 转换为布尔值是 False
print(bool(None))#False

#[]空列表
print(bool([]))#False

#()空元组
print(bool(()))#False

#空集合
s = set()
print(bool)

#在Python中，只有空字符串'',&quot;&quot;,数字0，空字典{},空列表[],空元组(),空数据None会被转换为False
#其他的都会转换为True

#在计算机里，True和False其实就是使用数字 1 和 0来保存的
print(True + 1) # 2
print(False + 1)# 1
</code></pre>
<h3 id="运算符"><strong>运算符</strong></h3>
<pre><code class="language-python">#算术运算符在数字里的使用

** 幂运算
		**等价于^，例如2 * *10=1024
   开平方：
		print(81 ** (1/2))
    **=
    
    
// 整除
print(10 /  3)	#3.333333333
print(10 // 3)	#3
	//=

#除法
#在Python 3里，两个整数相除，得到的结果会是浮点数	10/3——&gt;3.333333
#在Python 2里，两个整数相除，得到的结果会是一个整数	10/3——&gt;3

print(6/2) # 3.0
print(9/2) # 4.5
</code></pre>
<pre><code class="language-python">#算术运算符在字符串里的使用
#字符串里支持的算术运算符有限，只支持加法和乘法
#加法运算符：只能用于两个字符串拼接，数字和字符串之间不能做加法运算
#乘法运算符：只能用于数字和字符串之间，用来将一个字符串重复多次
print('hello' * 2) #hellohello
</code></pre>
<pre><code class="language-python">m,n = 3,5	#拆包
print(m,n)	# 3 5

x = 'hello','good','yes'	#元组，（）可以省略
print(x)	#('hello','good','yes')

#拆包时，变量的个数和值的个数不一致会报错，不能多也不能少
# y,z = 1,2,3,4,5	#有太多的值要解包了	error
# print(y,z)
#o,p,q = 4,2	#拆包的值不够	error
#print(o,p,q)

o,*p,q = 1,2,3,4,5,6		#	*p是可变长度，把1给o，6给q，[2,3,4,5]给p
print(o,p,q)		# 1 [2,3,4,5] 6

*o,p,q = 1,2,3,4,5,6	#	*o是可变长度，把6给q，5给p,[1,2,3,4]给o
print(o,p,q)		# [1,2,3,4] 5 6
o,p,*q = 1,2,3,4,5,6	# *q是可变长度，把1给o，2给p,[3,4,5,6]给q
print(o,p,q)		# 1 2 [3,4,5,6]
</code></pre>
<pre><code class="language-python">#比较运算符
#字符串之间使用比较运算符，会根据各个字符的ASCII码值逐一进行比较
print('a'&gt;'b') #False
print('abc'&gt;'b')#False		979899 &gt; 98  是97和98比较，这就是逐一比较的意思

#数字和字符串之间，做 == 运算的结果是False，做！=运算的结果是True，不支持其他的比较运算
print('a' == 90)#False
print('a' != 97)#True
print('a' &gt; 90)#error
</code></pre>
<pre><code class="language-python">#逻辑运算符
    # 逻辑与 and	逻辑或 or	逻辑非 not
    print(2 &gt;1 and 5 &gt; 3 and 10 &gt; 2)
    #逻辑与运算做取值时，取第一个为False的值；如果所有的运算数都是True，取最后一个值
    print('good' and 'yes' and 'ok' and 100)#100
    #逻辑或运算做取值时，取第一个为True的值；如果所有的运算数都是False，取最后一个值
    print(0 or [] or {} or ())#()
</code></pre>
<pre><code class="language-python">#位运算符与C语言相同
</code></pre>
<pre><code class="language-python">#运算符的优先级
逻辑运算符的优先级：not &gt; and &gt;or 
强烈建议：在开发中，使用括号来说明运算符的优先级
</code></pre>
<pre><code class="language-python">#python不支持switch……case语句
——————————————————————————————————————————————————————————————————————————————

#if结构：
if 条件判断：
	条件成立时执行的代码，前方有缩进
    
   
例子：
age = int(input(&quot;请输入你的年龄：&quot;))#注意：这里input得到的是字符串，不能和数字比较，
									#需要类型转换
if age &lt; 18:
    print('未满18岁禁止入内')
    
——————————————————————————————————————————————————————————————————————————————
#if……else结构
if 条件判断：
	条件成立时执行的代码
else：
	条件不成立时执行的代码
#注意：if和else后面都要跟：冒号
#		下方要执行的代码需要有缩进

age = int(input(&quot;请输入你的年龄：&quot;))
if age &lt; 18:
    print('未满18岁禁止入内')
else:
    print('请进')
——————————————————————————————————————————————————————————————————————————————
score = int(input('请输入你的分数\n'))
if 60 &gt; score &gt;= 0:
    print('不及格')
elif 80 &gt; score &gt;= 60:		#这里的 elif 是else if 的意思，但Python不支持写else if 
    print('良好')
elif 90 &gt; score &gt;= 80:
    print('优秀')
elif 100 &gt;= score &gt;=90:
    print('真棒')
else:
    print('请输入正确的分数')
—————————————————————————————————————————————————————————————————————————————— # Python语言里，使用强制缩进来表示语句间的结构 
</code></pre>
<pre><code class="language-python">#pass 关键字在Python里没有意义单纯的用来占位，保证语句的完整性
例子：
age = int(input('请输入您的年龄：'))
if age &gt; 18:
    pass			#这里pass用来占位，但这条语句没有含义，如果缺少了pass就会报错
print('hello')
</code></pre>
<pre><code class="language-python">#三元表达式

num1  = int(input('请输入一个数字：'))
num2  = int(input('请再输入一个数字：'))

x = num1 if num1 &gt; num2 else num2
'''
等价于
if num1 &gt; num2:
	x = num1
else:
	x = num2
'''

print('两个数里的较大数是',x)
</code></pre>
<h3 id="循环"><strong>循环</strong></h3>
<pre><code class="language-python">python里不支持do……while循环
python里也没有自增自减运算符

#while循环
x = 10
while x &lt; 10:#注意这里也有：冒号
    print('hello')
    x++
    
#for···in 循环
Python的for循环指的是for……in 循环
#for……in循环格式：
for x in [1,2,3,4,5,6,7,8,9]	#注意：in后面必须要是一个可迭代对象！！！
#目前接触的  可迭代对象：字符串、列表、字典、元组、集合、range

#range 内置类用来生成指定区间的整数序列（列表）
#range 生成的是左开右闭区间
for x in range(1,11):
    print(x)#输出1-10
等价于：for x in [1,2,3,4,5,6,7,8,9,10]:
    print(x)

用for……in循环打印1到100的和：
for x in range(1,101):
    z +=j
print(z)    
</code></pre>
<h4 id="break和continue"><strong>break和continue</strong></h4>
<pre><code class="language-python">#break和continue在Python里只能用于循环语句中

#break用来结束整个循环

#continue用来结束本轮循环，开启下一轮循环
</code></pre>
<h4 id="嵌套循环"><strong>嵌套循环</strong></h4>
<p>外循环控制行数，内循环控制列数</p>
<pre><code class="language-python">for……else
for……else语句：当循环里break没有被执行的时候，就会执行else
</code></pre>
<h3 id="字符串"><em><strong>字符串</strong></em></h3>
<h4 id="字符串的表示方式">字符串的表示方式</h4>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">串</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">类</mi><mi mathvariant="normal">型</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">串</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">任</mi><mi mathvariant="normal">何</mi><mi mathvariant="normal">操</mi><mi mathvariant="normal">作</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">都</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">改</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">原</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">串</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{字符串是不可变数据类型，对于字符串的任何操作，都不会改变原有的字符串}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">字</span><span class="mord cjk_fallback" style="color:red;">符</span><span class="mord cjk_fallback" style="color:red;">串</span><span class="mord cjk_fallback" style="color:red;">是</span><span class="mord cjk_fallback" style="color:red;">不</span><span class="mord cjk_fallback" style="color:red;">可</span><span class="mord cjk_fallback" style="color:red;">变</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">据</span><span class="mord cjk_fallback" style="color:red;">类</span><span class="mord cjk_fallback" style="color:red;">型</span><span class="mord cjk_fallback" style="color:red;">，</span><span class="mord cjk_fallback" style="color:red;">对</span><span class="mord cjk_fallback" style="color:red;">于</span><span class="mord cjk_fallback" style="color:red;">字</span><span class="mord cjk_fallback" style="color:red;">符</span><span class="mord cjk_fallback" style="color:red;">串</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">任</span><span class="mord cjk_fallback" style="color:red;">何</span><span class="mord cjk_fallback" style="color:red;">操</span><span class="mord cjk_fallback" style="color:red;">作</span><span class="mord cjk_fallback" style="color:red;">，</span><span class="mord cjk_fallback" style="color:red;">都</span><span class="mord cjk_fallback" style="color:red;">不</span><span class="mord cjk_fallback" style="color:red;">会</span><span class="mord cjk_fallback" style="color:red;">改</span><span class="mord cjk_fallback" style="color:red;">变</span><span class="mord cjk_fallback" style="color:red;">原</span><span class="mord cjk_fallback" style="color:red;">有</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">字</span><span class="mord cjk_fallback" style="color:red;">符</span><span class="mord cjk_fallback" style="color:red;">串</span></span></span></span></span></span></p>
<pre><code class="language-python">#在python里，可以使用一对单引号、一对双引号、一对三个双引号、一对三个单引号都可以表示字符串
#如果字符串里面还有双引号，外面就可以使用单引号

#字符串的转义字符 \
x = 'I\'m xiaoming'	# \ 表示的是转义字符，作用是对 \ 后面的字符进行转义
——————————————————————————————————————————————————————————————————————————————
#字符串的下标和切片

# 下标我们又称之为索引，表示第几个数据
str list tuple 可以通过下标来获取或操作数据
下标都是从0开始的

Word = ’zhangsan'
print(word[4])
#字符串是不可变数据类型，对于字符串的任何操作，都不会改变原有的字符串
——————————————————————————————————————————————————————————————————————————————
#切片
#切片就是从字符串中复制一段指定的内容，生成一个新的字符串
m = 'abcdefghijklmnopqrstuvwxyz'
print(m[5])#m[index] ==&gt; 获取指定下标上的数据
#切片语法   m[stard:end:step]
#也是左闭右开区间
#step指的是步长，理解为在指定区间内，每step个取一次

print(m[2:9])#cdefghi  ==&gt;[2,9)
print(m[2:])#如果只设置了start，后面默认到最后    cdefghijklmnopqrstuvwxyz
print(m[:9])#如果只设置了end，会从头开始取值      abcdefghi
#步长默认为1
print(m[2:9:2])#步长为2，                         cegi
#步长不能为0，但可以为负数
print(m[3:15:-1])#打印的是空的，-1是从右往左找，从下标为3的地方往左找下标为15
print(m[15:3:-1])#注意：这里包含15，不包含3         ponmlkjihgfe
print(m[::])#从左往右全部复制一份
print(m[::-1])#从右往左全部复制一份
#stard和end为负数表示从右往左数
print(m[-5:-9])#空
print(m[-9:-5])#rstu    注意：这里步长为1是正数，从左往右取
</code></pre>
<h4 id="字符串的常见操作"><strong>字符串的常见操作</strong></h4>
<pre><code class="language-python">x = 'abcdefghijklmnopqrstuvwxyz'

#获取字符串的长度
#使用内置类len
print(len(x))#26

#查找内容相关方法
#find/index/rfind/rindex
#可以获取指定字符的下标
#s.find(sub[,start[,end]]) -&gt; int 返回的一定是一个int值
print(x.find('l')) #11

print(x.index('l')) #11

#find和index的区别：
print(x.find('P'))  #-1 如果字符在字符串里不存在，结果是-1
print(x.index('P')) # ValueError: substring not found   字符在字符串里不存在会报错
#使用find，如果字符在字符串里不存在，会返回-1
#使用index，如果字符在字符串里不存在，会直接报错

#find用法2：
print(x.find('l',4,9))#在下标4到9的范围内寻找字符'l'

'''
s.find(sub[, start[, end]]) -&gt; int 
Return the lowest index in S where substring sub is found, 
such that sub is contained within s[ start: end]. Optional 
arguments start and end are interpreted as in slice notation.
 Return -1 on failure.
 
s.find（sub [，start [，end]]）-&gt; int
返回S中找到子字符串sub的最低索引，
这样sub包含在s [start：end]中。可选的
参数start和end被解释为切片表示法。
失败时返回-1。
'''
#rfind和rindex都是找最大的下标，它们和find，index它们的区别与find和index的区别是一样的

# startswith,endswith, isalpha,isdigit, isalnum, isspace
# is开头的是判断，结果是一个布尔类型
print('he1lo'.startswith('he')) #True   startswith  判断字符串是不是以括号里面的字符为开头
print('hello'.endswith('o'))    #True   endswith    判断字符串是不是以括号里面的字符为结尾
print('hello'.isalpha())# True  判断字符串是不是都字母     alpha字母
print('123'.isdigit())#True     判断字符串是否都是正整数   digit数字
#alnum判断字符串是否由正整数或字母组成
print('ab123hello'.isalnum())#True
print('123'.isalnum())#True
print('abhello'.isalnum())#True
print('4 - 1'.isalnum())#False
print('    '.isspace())#True是否全部由空格组成
'''

计算出现次数：count
返回 str 在start和end之间在mystr里面出现的次数
语法格式：
s.count(sub[,start[,end]]) -&gt; int
示例：
mystr = '今天天气好晴朗，处处好风光'
print(mystr.count('好')) #3  '好'出现了三次
'''

&quot;&quot;&quot;
#替换内容：replace
替换字符串中指定的内容，如果指定次数count，则替换不会超过count次
mystr ='今天天气好晴朗，处处好风光呀好风光'
newstr = mystr.replace（'好','坏'）
print(mystr)#今天天气好晴朗，处处好风光呀好风光  原字符串未改变！
print(newstr)#今天天气坏晴朗，处处坏风光呀坏风光得到的新字符串里，'好'被修改成了'坏'

newstr = mystr.replace（'好'，坏'，2）#指定了替换的次数
print（newstr）#今天天气坏晴朗，处处坏风光呀好风光只有两处的‘好被替换成了‘坏
&quot;&quot;&quot;
#切割字符串split,rsplit,splitlines,partition,rpartition
#字符串类型的数据
x = 'zhangsan-lisi-wnagwu-jerry-henry-merry-jack-tony'
#['zhangsan','lisi','wangwu','jerry','henry','merry','jack','tony']
#使用split方法，可以将一个字符串切割成一个列表
y = x.split('-')
print(y)    #切割以后的结果就是一个列表['zhangsan','lisi','wangwu','jerry','henry','merry','jack','tony']
#rsplit
z = x.rsplit('-')#从右往左切
print(z)#['zhangsan','lisi','wangwu','jerry','henry','merry','jack','tony']
#print(x.split('-',2))的2是分割两次的意思，2控制分割次数，不写默认全部分割
print(x.split('-',2))#['zhangsan', 'lisi', 'wnagwu-jerry-henry-merry-jack-tony']
print(x.rsplit('-',2))#['zhangsan-lisi-wnagwu-jerry-henry-merry', 'jack', 'tony']

#splitlines 按照行分隔，返回一个包含各行作为元素的列表
#partition  指定一个字符串作为分隔符，分为3部分
# 字符前面    字符   字符后面   

print('acdefXmpXqwrst'.partition('X')) #('acdef', 'X', 'mpXqwrst')
print('acdefXmpXqwrst'.rpartition('X')) #('acdefXmp', 'X', 'qwrst')

#获取文件名和后缀名
file_name = '不要打开.mp4'
print(file_name.rpartition('.')) #('不要打开', '.', 'mp4')

#修改大小写capitalize,title,upper,lower
#空格处理ljust,rjust,center,lstrip,rstrip,strip
#字符串拼接:join
</code></pre>
<h4 id="字符集">字符集</h4>
<pre><code class="language-python">#字符集
#ASCII--&gt;Latin 1--&gt;Unicode编码
print(ord('a')) #97
print(chr(65))  #A

print(ord('你'))#20320
print(ord('我'))#25105
print(ord('爱'))#29233
#这里是Unicode编码哦
print(chr(25105),chr(29233),chr(20320))

#编码集
#GBK    国标扩     汉字占两个字节     简体中文    也就是GB2312
#BIG5   繁体中文
#utf-8  统一编码   汉字占三个字节

#使用encode字符串转换成指定编码集结果
print('你'.encode('gbk'))    #b'\xc4\xe3'        50403   11000100 11100011
print('你'.encode('utf8'))   #b'\xe4\xbd\xa0'            11100100 10111101   10100000
</code></pre>
<p>成员运算符</p>
<pre><code class="language-python">#in 和 not in    运算符
#用来判断一个内容在可迭代对象里是否存在
if x in word:
    print('存在')
else:
    print('不存在')
    
#格式化打印字符串
name = '张三'
age = 18
print('大家好，我的名字是%s,我今年%d岁了，我今天挣了%f元钱'%(name,age,3.14))
#基本和C语言一样
a = 255
print('%x' % a) #ff
</code></pre>
<pre><code class="language-python">#字符串format
#{}也可以进行占位
#{}里面什么都不写，会直接读取后面的内容，一一对应填充
x = '大家好，我是{}，我今年{}岁了'.format('张三',18)
print(x)

#{数字}根据数字的顺序来进行填入，数字从0开始
y = '大家好，我是{1},我今年{0}岁了'.format(20,'jerry')
print(y)

#{变量名}
z = '大家好，我是{name}，我今年{age}岁了,我来自{addr}'.format(age=18,name='jack',addr='瑞金')
print(z)

#混合使用{数字} {变量}                                  这里变量要写在数字之后
a = '大家好，我是{name}，我今年{1}岁了,我来自{0}'.format('瑞金',18,name='Tom')
print(a)
 
#{}什么都不写    (数字)不能混合使用

d = ['zhangsan',18,'上海',180]
#b = '大家好，我是{},我今年{}岁了，我来自{},身高{}cm'.format(d[0],d[1],d[2],d[3])
b = '大家好，我是{},我今年{}岁了，我来自{},身高{}cm'.format(*d)# *d可以直接对列表进行拆分
print(b)

info={'name':'cheis','age':23,'addr':'北京','height':190}
c = '大家好，我是{name},我来自{addr},身高{height}cm,我今年{age}岁了'.format(**info)
#这里用**
print(c)
</code></pre>
<h4 id="列表的基本使用">列表的基本使用</h4>
<pre><code class="language-python">#当我们有多个数据需要按照一定顺序保存时，我们可以考虑列表
#name1 = '张三'
#name2 = '李四'
#name3 = '王五'
#name4 = 'Jack'

#使用[]来表示一个列表，列表里的每一个数据我们称之为元素
#元素之间用逗号进行分割
names = ['张三','李四','王五','Jack','张飞','关羽','刘备','曹操','孙权']
print(names)

#可以用 list(可迭代对象) 将可迭代对象转换成为一个列表
names = list(('张三','李四','王五','Tony','张飞','关羽','刘备','曹操','孙权'))
print(names)

#和字符串一样，都可以使用下标来获取元素和对元素进行切片
#同时，我们还可以使用下标来修改列表里的元素，但字符串不能修改，字符串是不可变数据类型
#列表可以修改

print(names[3])
names[3] = '诸葛亮'
print(names)

print(names[3:5])#也是左闭右开区间

#列表的操作

#列表是用来保存多个数据的，是有序可变的
#操作列表，一般都包含增加数据，删除数据，修改数据以及查询数据
#增删改查

heros = ['刘备','张飞','关羽','曹操','孙权','诸葛亮']

#添加元素的方法    append insert extend
heros.append('孙策')
print(heros)#append 在列表的最后面追加一个数据

#insert(index,object)   需要两个参数  index表示下标   object表示对象，具体插入到哪个数据前面
heros.insert(4,'大乔')
print(heros)

x = ['周瑜','黄盖','司马懿']
#exitend(interanle)需要一个可迭代对象
#A.entend(B) ==&gt; 将可迭代对象B添加到A里

heros.extend(x)

print(heros)
print(x)

#列表的删除
heros = ['刘备','张飞','关羽','曹操','孙权','诸葛亮','Jerry']
#pop remove clear
x = heros.pop()#pop默认删除列表最后一个数据，并且返回这个数据
print(x)
print(heros)
x = heros.pop(3)#pop可以删除指定位置上的数据，也可以返回被删除的这个数据
print(x)
print(heros)

#用来删除指定的元素
heros.remove('张飞')#如果数据在列表中不存在会报错
print(heros)

#clear 用来清空一个列表
heros.clear()
print(heros)

#查询列表元素
三国 = ['魏','蜀','吴']
print(三国.index('吴'))#查询元素的位置    如果元素不存在会报错
print(三国.count('吴'))#查询出现的次数

print('魏'in 三国)

#列表的修改
#使用下标可以直接修改列表里的元素
三国[1] = 'shu'
print(三国)

#列表的遍历
#遍历：将所有数据都访问一遍，遍历针对的是可迭代对象
#while遍历    for...in遍历
水浒传 = ['宋江','晁盖','吴用','林冲','公孙胜','卢俊义','呼延灼','柴进','鲁智深','武松','李逵','阮小五','阮小七','扈三娘','时迁','白胜','孙二娘']
#for in 循环的本质就是不断调用迭代器的 next 方法查找下一个数据
for k in 水浒传:
    print(k)
    
i = 0
while i &lt;   len(水浒传):
    print(水浒传[i])
    i += 1
    
#列表的排序和反转
nums = [9,5,7,6,8,2,1,3,4,6]
#调用列表的sort方法可以直接对列表进行排序
#sort直接对原有的列表进行排序
nums.sort()
print(nums)
#反转
nums.sort(reverse = True)
print(nums)

#内置函数sorted
#内置函数sorted不会改变原有的列表数据，而是会生成一个新的有序数据
x = sorted(nums)
print(nums)
print(x)

#reverse
numes = ['zhangsan','lisi','wangwu']
names.reverse()
print(numes)

print(numes[::-1])

#可变数据类型和不可变数据类型
num1 = [100,200,300]
num2 = num1
print('前num1=%X,num2=%X'%(id(num1),id(num2)))
num1[0] = 1
print(num1)
print('后num1=%X,num2=%X'%(id(num1),id(num2)))

'''
python里的数据都是保存在内存里的
python里的数据又分为可变类型和不可变类型
不可变类型：字符串、数字、元组
可变类型：   列表、字典、集合
不可变数据类型如果修改值，内存地址会发生变化
可变数据类型如果修改值，内存地址不会发生变化

使用内置函数id可以获取到一个变量的内存地址
'''
a=12
b=a
print('前a=%X,b=%X'%(id(a),id(b)))
a=10
print('后a=%X,b=%X'%(id(a),id(b)))

'''
p80
'''
#列表的复制
x = [100,200,300]
y = x   #x和y指向了同一个内存空间，会相互影响
x[0] = 1
print(y)
print(x)

#调用列表的copy方法可以直接对列表进行复制,这个列表和原有列表内容一样，但指向不同的内存空间
z = x.copy()
print(z)

print('%X %X %X' % (id(x),id(y),id(z)))

#除了使用列表自带的copy方法以外，还可以使用copy模块实现拷贝

import copy

a = copy.copy(x)#效果等价于x.copy()，都是一个浅拷贝

#深拷贝


#切片就是一个浅拷贝
names1 = ['张三','李四','王五','杰克马','汤姆','露西','莉莉']
names2 = names1[::]
names1[0] = 'jerry'
print(names2)

</code></pre>
<p>注释</p>
<p>#是单行注释</p>
<p>'''多行注释</p>
<p>三个单引号开始</p>
<p>三个单引号结束</p>
<p>中间写注释</p>
<p>'''</p>
<p>“”“</p>
<p>三个双引号也是多行注释</p>
<p>“”“</p>
<p>交互式编程用exit()退出</p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5CHP%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200331204642682.png" alt="image-20200331204642682" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言大纲]]></title>
        <id>https://Token.github.io/post/c-yu-yan-da-gang/</id>
        <link href="https://Token.github.io/post/c-yu-yan-da-gang/">
        </link>
        <updated>2020-04-28T02:32:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c语言概述">C语言概述</h1>
<h2 id="1为什么学习c语言">1.为什么学习C语言</h2>
<pre><code>    1）.C的起源和发展（PPT）
    2）.C的特点
	优点
		代码量小	速度快		功能强大
	缺点
		危险性高
		开发周期长
		可移植性不强
3）.C的应用领域
4).C的重要性
</code></pre>
<p>2.怎样学习C语言<br>
3.学习的目标<br>
4.常见问题答疑<br>
1.学习Java为什么建议先学C语言<br>
2.没学过计算机专业课程能够学懂C语言<br>
3.英语和数学不好能学好C么？<br>
5.课程计划<br>
Image<br>
6.举例子:一元二次方程<br>
#include&lt;stdio.h&gt;<br>
#include&lt;math.h&gt;</p>
<p>int main(void)<br>
{<br>
int a = 1;<br>
int b = 5;<br>
int c = 6;<br>
double delta,x1,x2;<br>
delta = b<em>b - 4</em>a*c;</p>
<pre><code>if(delta &gt; 0)
{
	x1 = (-b + sqrt(delta))/(2*a);
	x2 = (-b - sqrt(delta))/(2*a);
	printf(&quot;该一元二次方程有两个解，x1 = %f,x2 = %f\n&quot;,x1,x2);
}
else if(delta == 0)
{
	x1 = (-b) / (2*a);
	x2 = x1;
	printf(&quot;该一元二次方程有一个唯一解，x1 = x2 = %f&quot;,x1,x2);
}
else
{
printf(&quot;无解\n&quot;);
}

return 0; 
</code></pre>
<p>}</p>
<p>C语言编程预备知识<br>
1.CPU 内存条 硬盘 显卡 主板 显示器 之间的关系<br>
2.helloword程序如何运行起来的<br>
3.什么是数据类型<br>
整数<br>
整型 —— int ——4<br>
短整型 —— short int ——2<br>
长整型 —— long int —— 8<br>
浮点数（实数）<br>
单精度浮点数 —— float —— 4<br>
双精度浮点数 —— double —— 8</p>
<pre><code>字符
	char——1
复合类型数据
	结构体
	枚举
	共用体
</code></pre>
<p>4.什么是变量<br>
变量的本质就是内存中一段存储空间<br>
5.CPU 内存条 VC++6.0 操作系统 之间的关系<br>
Image<br>
Image<br>
Image<br>
Image<br>
Image<br>
Image<br>
Image<br>
6.变量为什么必须初始化<br>
所谓初始化就是赋值的意思<br>
7.如何定义变量<br>
数据类型 变量名 = 要赋的值；<br>
等价于<br>
数据类型 变量名；<br>
变量名 = 要赋的值；<br>
举例子：<br>
int i = 3；	等价于	int i ；i = 3；<br>
int i，j；	等价于 inti；int j；<br>
int i，j=3	等价于 int i；int j；j=3；<br>
int i=3，j=5；等价于 int i；int j；i=3；j=5；<br>
int i，j；	i=j=5； 等价于 int i，j； i=5 j=5；<br>
8.什么是进制（PPT）<br>
十进制就是逢十进一<br>
二进制就是逢二进一<br>
9.常量在C语言中是如何表示的<br>
整数<br>
十进制：	传统的写法<br>
十六进制：	前面加Ox或OX<br>
八进制：	前面0	注意是数字0不是字母O<br>
浮点数<br>
传统的写法<br>
float x =3.2;//传统<br>
科学计数法<br>
float x = 3.2e3；	//x的值是 3200<br>
float x = 123.45e-2;	//x的值是1.2345<br>
字符<br>
单个字符用单引号括起来<br>
'A'表示字符A<br>
'AB'错误<br>
&quot;AB&quot;正确<br>
字符串用双引号括起来<br>
&quot;A&quot;正确，因为&quot;A&quot;代表了'A''\0'的组合<br>
10.常量以什么样的二进制代码储存在计算机中<br>
整数是以补码的形式转化为二进制代码存储在计算机中<br>
实数是以IEEE754标准转化为二进制代码存储在计算机中的<br>
字符的本质实际也是与整数的存储方式相同<br>
11.代码规范化<br>
代码的可读性更强[容易让自己和别人更容易看懂程序]<br>
降低代码出错的可能性<br>
12.什么是字节<br>
字节就是存储数据的单位，并且是硬件所能访问的最小单位<br>
1 字节 = 8 位<br>
1 K = 1024 字节<br>
1 M = 1024 K<br>
1 G = 1024 M<br>
13.不同类型数据之间相互赋值的问题<br>
(补码)<br>
int i = 45；<br>
long j = 102345；<br>
i = j；<br>
printf(&quot;%d %d\n&quot;,i,j);<br>
float x = 6.6;<br>
double y = 8.8;<br>
printf(&quot;%f %lf\n,x,y&quot;);<br>
int i = ;<br>
14.什么是ASCII<br>
ASCII不是一个值，而是一种规定，<br>
ASCII规定了不同的字符是使用哪个整数值去表示<br>
它规定了<br>
'A' —— 65<br>
'B' —— 66<br>
'a' —— 97<br>
'b' —— 98<br>
'0' —— 48<br>
15.字符的存储[字符本质上与整数的存储方式相同]<br>
基本的输入和输出函数的用法<br>
printf( )——将变量内容输出到显示器上<br>
四种用法<br>
1.printf(&quot;字符串&quot;)；<br>
2.printf(&quot;输出控制符&quot;，输出参数);<br>
3.printf(&quot;输出控制符1 输出控制符2 ……&quot;，输出参数1，输出参数			2……);输出控制符和输出参数的个数必须一一对应<br>
4.printf(&quot;输出控制符 非输出控制符&quot;，输出参数);<br>
输出控制符包含如下<br>
%d			——		int<br>
%ld			——		long int<br>
%c			——		char<br>
%f			——		float<br>
%lf			——		double						%x(或者%X或者%#X)	——	int或long int或short int<br>
%o			——		同上<br>
%s			——		字符串<br>
#include &lt;stdio.h&gt;<br>
int main(void)<br>
{<br>
int i = 1000;<br>
printf(&quot;%x\n&quot;,i);<br>
printf(&quot;%X\n&quot;,i);<br>
printf(&quot;%#x\n&quot;,i);<br>
printf(&quot;%#X&quot;,i);//最优<br>
return 0;																				<br>
}<br>
为什么需要输出控制符<br>
1. 01组成的代码可以表示数据也可表示指令<br>
2. 如果01组成的代码表示的是数据的话，那么同样的01代码组合以不同的输出格式输出就会有不同的输出结果</p>
<p>scanf( )【通过键盘将数据输入到变量中】<br>
用法一： scanf(&quot;输入控制符&quot;，输入参数)；<br>
功能：		将从键盘输入的字符转化为输入控制符所规定格式的数据，然			后存入以输入参数的值为地址的变量中<br>
用法二：	scanf(&quot;非输入控制符 输入控制符&quot;，输入参数)；<br>
功能：		将从键盘输入的字符转化为输入控制符所规定格式的数据，然			后存入以输入参数的值为地址的变量中<br>
非输入控制符必须原样输入<br>
如何使用scanf编写出高质量代码<br>
1. 使用scanf之前最好先使用printf提示用户以什么样的方式来输入<br>
2.scanf中尽量不要使用非输入控制符，尤其是不要用\n<br>
3.应该编写代码对用户的非法输入做适当的处理【非重点】<br>
while ((ch=getchar()) !='\n')<br>
continue;<br>
运算符<br>
算术运算符<br>
+ 	 - 	 * 	 /（除） 	 %（取余数）<br>
关系运算符<br>
&gt;	 &gt;= 	&lt; 	&lt;= 	!= 	==<br>
逻辑运算符<br>
！（非）	&amp;&amp;（并且）	||（或）<br>
C语言对真假的处理<br>
非零是真<br>
零是假<br>
真是1表示<br>
假是0表示<br>
&amp;&amp;左边的表达式为假 右边的表达式肯定不会执行<br>
||左边的表达式为真 右边的表达式肯定不会执行<br>
赋值运算符<br>
=	+=（a+=3;等价于a=a+3）	*=	 /=	 -=<br>
优先级别：<br>
算术 &gt; 关系 &gt; 逻辑 &gt; 赋值<br>
附录的一些琐碎的运算符知识<br>
自增	自减	三目运算符	逗号表达式<br>
自增[或者自减]<br>
分类：<br>
前自增 —— ++i<br>
后自增 —— i++<br>
前自增和后自增的异同<br>
相同：<br>
最终都使i的值加一<br>
不同：<br>
前自增整体表达式的值是i加1之后的值<br>
后自增整体表达式的值是i加1之前的值<br>
为什么会出现自增<br>
代码更精炼<br>
自增的速度更快<br>
学习自增要明白的几个问题<br>
1.我们编程时尽量避免使用前自增和后自增的差别<br>
2.i++ 和 ++i  单独成一个语句，不要把它作为一个完整复合语句的一			部分来使用（自增表达式最好不要作为一个更大的表达式的一			部分来使用）<br>
如：76<br>
int m = i++ + ++i + i + i++；//这样写不但是不规范的代码<br>
而且是不可移植的代码<br>
printf（&quot;%d %d %d&quot;,i++,++i,i）;//同上<br>
2.三目运算符？：<br>
格式：<br>
A ？ B ：C<br>
等价于<br>
IF（A）<br>
B；<br>
else<br>
C；<br>
3.逗号表达式<br>
格式：<br>
（A，B，C，D）<br>
功能：从左往右执行<br>
最终表达式的值是最后一项的值<br>
Image<br>
Image<br>
流程控制【学习C语言的第一个重点】<br>
1.什么是流程控制<br>
代码执行的顺序<br>
2.流程控制的分类<br>
顺序</p>
<pre><code>	选择
		定义
		    某些代码可能执行，也有可能不执行，有选择的执行某些代码
		分类
			IF
				1.IF最简单的用法
				格式：
					IF（表达式）
						语句
				功能：
					如果表达式为真，执行语句
					如果表达式为假，语句不执行
				2.IF的范围问题
				    1.
					IF（表达式）
						语句A；
						语句B；
					解释：IF默认只能控制语句A的执行或不执行
						IF无法控制语句B的执行或不执行
						或者讲：语句B一定会执行
				    2.
					IF（表达式）
					｛
						语句A；
						语句B；
					｝
					此时IF可以控制语句A和语句B
				由此可见：IF默认只能控制一个语句的执行或不执行
					    如果想控制多个语句的执行或不执行
					    就必须把这些语句用｛｝括起来
				3.IF...else...的用法
				4.IF...else...IF...else...的用法
				5.C语言对真假的处理
				6.IF举例——求分数等级
				7.IF的常见问题解析
</code></pre>
<p>ImageImageImage<br>
Image<br>
Image<br>
Image<br>
Image</p>
<p>学习C语言的方法：<br>
Image<br>
如果程序实在无法彻底理解，就将它背会</p>
<pre><code>			switch
				把电梯程序看懂就行了
</code></pre>
<p>Image<br>
Image</p>
<p>Image<br>
Image<br>
Image<br>
循环<br>
定义：<br>
某些代码会被重复执行<br>
分类<br>
for<br>
1.格式：<br>
for（1；2；3）<br>
语句A；<br>
2.执行的流程【重点】<br>
单个for循环的使用<br>
多个for循环的嵌套使用<br>
for（1；2；3）<br>
for（4；5；6）<br>
A；<br>
B;</p>
<pre><code>				3.范围问题，
					for也默认只控制一条语句
				4.举例
					1+2+3+……+100
					1+1/2+1/3+……+1/100
</code></pre>
<p>强制类型转换<br>
格式：<br>
（数据类型）（表达式）<br>
功能：<br>
把表达式的值强制转化为前面所执行的数据类型<br>
例子：<br>
（int）（4.5+2.2）最终值是 6<br>
（float）（5）	最终值是 5.000000<br>
浮点数的错存所带来的问题<br>
float和double都不能保证可以精确的存储一个小数<br>
举例：<br>
float i = 99.9;<br>
printf(&quot;%f\n&quot;,i);<br>
输出结果为：99.900002<br>
因为浮点数无法正确存储，所以就衍生出来的两个编程问题：<br>
有一个浮点型变量x，如何判断x的值是否为零<br>
if(|x-0.000001|&lt;=0.000001)<br>
是<br>
else<br>
不是<br>
为什么循环中更新的变量不能定义成浮点型</p>
<pre><code>			while
				1.执行顺序
					格式：
						while（表达式）
							语句；
				2.与for的相互比较
			for和while可以相互转换
			但for的逻辑性更强，更不容易出错，推荐多使用for
						for （1；2；3）
							A；
						等价于
						1；
						while（2）
						{
							A;
							3;
						}
				3.举例
				从键盘输入一个数字，如果该数字是回文数
				则返回yes，否则返回no
				4.什么时候使用while，什么时候使用for
					

			do……while
				格式：
</code></pre>
<p>do<br>
{<br>
……<br>
} while（表达式）；<br>
主要用于人机交互<br>
do……whille不等价于for和while<br>
break与continue<br>
break<br>
break如果用于循环是用来终止循环<br>
break如果用于switch，则是用于终止switch<br>
break不能直接用于IF，除非IF属于循环内部的一个子句<br>
例子：<br>
for(i=0;i&lt;3;++i)<br>
{<br>
if (3&gt;2)<br>
break;//break虽然是IF内部的语句，但break终止的却是外部的for循环<br>
printf(&quot;shuchu\n&quot;);<br>
}<br>
在多层循环中，break只能终止距离它最近的循环<br>
例子2：<br>
for(i=0; i&lt;3;++i)<br>
{<br>
for(j=1;j&lt;4;++j)<br>
break;//break只能终止距离它最近的循环<br>
printf(&quot;shuchu\n&quot;);<br>
}<br>
在多层switch中，break也只能终止距离它最近的switch<br>
continue<br>
用于跳过本次循环余下的语句，转去判断是否需要执行下次循环<br>
for<br>
Image<br>
清除输入正确后的非法字符，例如：123zxc经过下列程序后就会清除后面的zxc<br>
Image<br>
数组<br>
为什么需要数组<br>
为了解决大量同类型数据的存储和使用问题<br>
为了模拟现实世界<br>
数组的分类<br>
一维数组<br>
怎样定义一维数组<br>
为n个变量连续分配存储空间<br>
所有的变量的数据类型必须相同<br>
所有变量所占的字节大小必须相等<br>
例子：<br>
int a[5];<br>
一维数组名不代表数组中的所有元素<br>
一维数组名代表数组第一个元素的地址<br>
有关一维数组的操作<br>
初始化<br>
完全初始化<br>
int a[5] = {1,2,3,4,5};<br>
不完全初始化，未被初始化的元素默认为0<br>
int a[5] = {1,2,3};<br>
不初始化，所有元素是垃圾值<br>
int a[5]；<br>
清零<br>
int a[5]  = ｛0｝；<br>
错误写法：<br>
int a[5];<br>
a[5] = {1,2,3,4,5};//错误<br>
只有在定义数组的同时才能整体赋值<br>
其他情况下整体赋值都是错误的<br>
int a[5] = ｛1,2,3,4,5｝；<br>
a[5] = 100;//error<br>
因为没有a[5]这个元素，最大只有a[4]<br>
int a[5] = {1,2,3,4,5};<br>
int b[5];<br>
如果要把a数组中的值全部赋给b数组<br>
错误的写法：<br>
b = a;//error<br>
正确的写法<br>
for (i=0;i&lt;5;++i)<br>
b[i] = a[i];</p>
<pre><code>				赋值
				排序
				求最大/小值
				倒置
				查找
				插入
				删除
				
	二维数组
		int a[3][4];
	总共是12个元素，可以当作3行4列看待，这12个元素的名字依次是
		a[0][0] a[0][1] a[0][2] a[0][3]
		a[1][0] a[1][1] a[1][2] a[1][3]
		a[2][0] a[2][1] a[2][2] a[2][3]
		a[i][j] 表示第i+1行 第j+1列的元素
		int a[m][n];该二维数组右下角的元素只能是a[m-1][n-1]
		初始化
			int a[3][4] = ｛1,2,3,4,5,6,7,8,9,10,11,12｝；
			int a[3][4] = ｛
				｛1,  2,  3,  4｝，
				｛5,  6,  7,  8｝，
				｛9, 10, 11, 12｝
			｝；
		操作 
			输出二维数组内容

			对二维数组排序
			求每一行的最大值
			判断矩阵是否对称
			矩阵的相乘
		输出二维数组内容：
	多维数组
		是否存在多维数组
			不存在
			因为内存是线性一维的
			n维数组可以当作每个元素是n-1维数组的一维数组
				比如：
					int a[3][4]；
					该数组是含有3个元素的一维数组
					只不过每个元素都可以再分为4个小元素
					int a[3][4][5];
					该数组是含有3个元素的一维数组
					只不过每个元素都是四行五列的二维数组
</code></pre>
<p>函数【C语言的第二个重点】：<br>
为什么需要函数<br>
避免了重复性操作<br>
有利于程序的模块化<br>
什么叫函数<br>
逻辑上：能够完成特定功能的独立的代码块<br>
物理上：能够接收数据[也可以不接收数据]<br>
能够对接收的数据进行处理<br>
能够将数据处理的结果返回[也可以不返回]<br>
总结：函数是个工具，它是为了解决大量类似问题而设计的<br>
函数可以当作一个黑匣子<br>
如何定义函数<br>
函数的返回值	函数名（函数的形参列表）<br>
｛<br>
函数的执行体<br>
｝<br>
1.函数定义的本质是详细描述函数之所以能够实现某个功能的具体方法<br>
2.return 表达式；的含义：<br>
1&gt;终止被调函数，向主调函数返回表达式的值<br>
2&gt;如果表达式为空，则只终止函数，不向主调函数返回任何值<br>
3&gt;break是用来终止循环和switch的，return是用来终止函数的<br>
例子：<br>
void f（）<br>
｛<br>
return；//只终止函数，不向主调函数返回任何值</p>
<p>｝<br>
int f（）<br>
｛<br>
return 10；//第一：终止函数，第二：向主调函数返回10<br>
｝<br>
3.函数返回值的类型也称为函数的类型，因为如果函数名前面的返回值		和函数执行体中的 return 表达式；中表达式类型不同的话，则最终函		数返回值的类型以函数名前的返回值为准<br>
例子：<br>
int f()<br>
{<br>
return 10.5;//因为函数返回值的类型为int<br>
所以最终f返回的是10而不是10.5<br>
}</p>
<pre><code>函数的分类
	有参函数 和 无参函数
	有返回值 和 无返回值
	库函数   和 用户自定义函数
	值传递   和 地址传递函数
	普通函数 和 主函数（main函数）
			一个程序必须有且只能有一个主函数
			主函数可以调用普通函数 普通函数不能调用主函数
			普通函数可以相互调用
			主函数是程序的入口和出口
</code></pre>
<p>函数内部的变量只在本函数内使用<br>
注意的问题<br>
函数调用和函数定义的顺序<br>
如果函数调用写在了函数定义的前面，则必须加函数前置声明<br>
函数前置声明：<br>
1.告诉编译器即将可能出现的若干个字母代表的是一个函数<br>
2.告诉编译器即将可能出现的若干个字母所代表的函数的形				参和返回值的具体情况<br>
3.函数声明是一个语句，末尾必须加分号<br>
4.对库函数的声明是通过#include&lt;库函数所在的文件名.h&gt;				来实现的<br>
形参和实参<br>
个数相同	位置一一对应	数据类型必须相互兼容<br>
如何在软件开发中合理的设计函数来解决实际问题<br>
一个函数的功能尽量独立，单一<br>
多学习，多模仿牛人的代码<br>
函数是C语言的基本单位，类是Java，c#，c++的基本单位<br>
常用的系统函数<br>
double sqrt(double x);<br>
求x的平方根<br>
int abs(int x)<br>
求x的绝对值<br>
double fabs（double x）<br>
求x的绝对值<br>
专题：<br>
递归<br>
变量的作用域和存储方式<br>
按照作用域分：<br>
全局变量<br>
在所有函数外部定义的变量叫全局变量<br>
全局变量使用范围：从定义位置开始到整个程序结束<br>
局部变量<br>
在一个函数内部定义的变量或函数的形参都统称为局部变量<br>
void () f(int i)<br>
{<br>
int j = 20;<br>
}<br>
局部变量使用范围：只能在本函数内使用<br>
注意的问题：<br>
全局变量和局部变量命名冲突的问题<br>
在一个函数内部如果定义的局部变量的名字和全局变量				名字一样时，局部变量会屏蔽掉全局变量<br>
按变量的存储方式<br>
静态变量<br>
自动变量<br>
寄存器变量<br>
指针：<br>
指针的重要性：<br>
表示一些复杂的数据结构<br>
快速的传递数据，减少了内存的耗用【重点】<br>
使函数返回一个以上的值【重点】<br>
能直接访问硬件<br>
能够方便的处理字符串<br>
理解面向对象语言中引用的基础</p>
<pre><code>	总结：指针是C语言的灵魂
指针的定义
	地址
		内存单元的编号
		从零开始的非负整数
		范围：4G【0—4G—1】
	指针
		指针就是地址，地址就是指针
		指针变量就是存放内存单元编号的变量，或者说指针变量就是			存放地址的变量
		指针和指针变量是两个不同的概念 
		但是要注意，通常我们叙述时会把指针变量简称为指针，实际			它们的	含义并不一样
		指针的本质就是一个操作受限的非负整数 
指针的分类
	1.基本类型指针【重点】
		参见文件：E:\Users\HP\Desktop\学习\指针_2.cpp
		附注：
			*的含义
				1.乘法
				2.定义指针变量
				3.指针运算符
					  该运算符放在该已经定义好的指针变量的前面
				  如果p是一个已经定义好的指针变量
				  则*p表示以p的内容为地址的变量
		如何通过被调函数修改主调函数普通变量的值
			1.实参必须为该普通变量的地址
			2.形参必须为指针变量
			3.在被调函数中通过
				*形参名  = ...
			的方式就可以修改主调函数相关变量的值
	2.指针和数组
		指针和一维数组
			一维数组名
				一维数组名是个指针常量
				它存放的是一维数组第一个元素的地址
			下标和指针的关系
				如果p是个指针变量，则
					p[i] 永远等价于 *（p+i）
			确定一个一维数组需要几个参数【如果一个函数要处理					一个一维数组，则需要接收该数组的哪些信息】					需要两个元素：
					数组第一个元素的地址
					数组的长度
			指针变量的运算
			    指针变量不能相加 不能相乘 也不能相除 只能相减
				如果两个指针变量指向的是同一块连续空间中的					不同存储单元，则这两个指针变量才能相减
				int a[5];
				p = &amp;a[1];
				q = &amp;a[4];
				printf(&quot;p和q相差了%d个单元&quot;，q-p);
			一个指针变量到底占几个字节【非重点】
				预备知识：
					sizeof（数据类型）
				    功能：返回值就是该数据类型所占的字节数
				    例子：sizeof（int）=4 sizeof（char)=1 							sizeof(double)=8
				sizeof(变量名）
				功能：返回值是该变量所占的字节数
</code></pre>
<p>当操作数是指针时，sizeof依赖于编译器。<br>
例如Microsoft　C/C++7.0中，<br>
near类指针字节数为2，far、huge类指针字节数为4。<br>
一般Unix的指针字节数为4。<br>
假设p指向char类型变量（1个字节）<br>
假设q指向int类型变量（4个字节）<br>
假设r指向double类型变量（8个字节）<br>
p q r 本身所占的字节数是否一样？<br>
答案：所占字节数是一样的<br>
总结：<br>
无论一个指针变量指向指向哪种变量，该						指针变量本身只占4个字节<br>
#include &lt;stdio.h&gt;</p>
<p>int main(void)<br>
{<br>
char ch = 'A';<br>
int i = 99;<br>
double x = 66.6;<br>
char * p = &amp;ch;<br>
int * q = &amp;i;<br>
double *r = &amp;x;</p>
<pre><code>printf(&quot;%d %d %d\n&quot;,sizeof(p),sizeof(q),sizeof(r));
 
return 0;
</code></pre>
<p>}<br>
/*<br>
————————————————————————————————————<br>
在VC++6.0中编译结果是4 4 4<br>
在Dev-C++中编译结果是8 8 8<br>
————————————————————————————————————<br>
*/<br>
一个变量的地址是用该变量首字节的地址来表示</p>
<pre><code>		指针和二维数组
	3.指针和函数
	4.指针和结构体
	5.多级指针
</code></pre>
<p>专题:<br>
动态内存分配【重难点】<br>
传统数组的缺点：<br>
1.数组长度必须事先规定，且只能是常整数，不能是变量<br>
例子：<br>
int a[5];//OK<br>
int len = 5;int a[len];//error<br>
2.传统形式定义的数组，该数组的内存程序员无法手动释放<br>
数组一旦定义，系统为该数组分配的存储空间就会一直存在，			直到该函数运行完毕时，数组的空间才会被释放<br>
3.数组的长度一旦定义，其长度就不能再更改<br>
数组的长度不能在函数运行的过程中动态的扩充或缩小<br>
4.A函数定义的数组，在A函数运行期间可以被其他函数使用，<br>
但A函数运行完毕后，A函数中的数组将无法被其他函数使用<br>
传统方式定义的数组不能跨函数使用<br>
为什么需要动态分配内存<br>
动态数组很好的解决了传统数组的这4个缺陷<br>
传统数组也叫静态数组<br>
动态内存分配举例_动态数组的构造</p>
<pre><code>	静态内存和动态内存的比较
		静态内存由系统自动分配，由系统自动释放
		静态内存是在栈分配的
		动态内存是由程序员手动分配，手动释放
		动态内存是在堆分配的
	多级指针
		
	跨函数使用内存的问题
</code></pre>
<p>结构体<br>
为什么需要结构体<br>
为了表示一些复杂的事物，而普通的基本类型变量无法满足实际要求	什么叫结构体<br>
把一些基本类型数据组合在一起形成的一个新的复合数据类型就是结构体<br>
如何去定义一个结构体<br>
3种方式，推荐使用第一种<br>
//第一种方式 这只是定义了一个新的数据类型，并没有定义变量<br>
struct Student<br>
{<br>
int age;<br>
float score;<br>
char sex;<br>
};<br>
//第二种方式<br>
struct Student2<br>
{<br>
int age;<br>
float score;<br>
char sex;<br>
}st2;<br>
//第三种方式<br>
struct<br>
{<br>
int age;<br>
float score;<br>
char sex;<br>
}st3;	<br>
怎么去使用结构体变量<br>
赋值和初始化<br>
定义的同时可以整体赋初值<br>
如果定义完之后，则只能单个的赋初值<br>
如何取出结构体变量中的每一个成员【重点】<br>
1.结构体变量名.成员名<br>
2.指针变量名-&gt;成员名	（第二种方式更常用）<br>
指针变量名-&gt;成员名在计算机内部会被转化成（*指针变							量名）.成员名的方式来执行<br>
所以说这两种方式是等价的<br>
例子：<br>
struct Student<br>
{<br>
int age;<br>
float score;<br>
char sex;<br>
};</p>
<p>int main(void)<br>
{<br>
struct Student st = {80,66.6,'F'};//初始化	定义的同时赋初值<br>
struct Student * pst = &amp;st;//&amp;st不能改成st</p>
<pre><code>st.sge = 10;//第一种方式 
pst-&gt;age = 88;//第二种方式 
return 0;
</code></pre>
<p>}</p>
<ol>
<li>
<p>pst-&gt;age 在计算机内部会转化成（*pst）.age，这就是-&gt;的含义，是一种硬性规定<br>
2.所以 pst-&gt;age等价于（*pst）.age也等价于 st.age<br>
3.我们之所以知道pst-&gt;age等价于 st.age，是因为pst-&gt;age是被转化成了（*pst）.age来执行</p>
</li>
<li>
<p>pst-&gt;age 的含义；<br>
pst所指向的那个结构体变量中的age这个成员<br>
结构体变量和结构体变量指针作为函数参数传递的问题<br>
推荐使用结构体指针变量作为函数参数来传递<br>
结构体变量的运算<br>
结构体变量不能相加，不能相减，也不能相互乘除<br>
但结构体变量可以相互赋值<br>
举例<br>
动态构造存放学生信息的结构体数组<br>
动态构造一个数组，存放学生的信息<br>
然后按分数排序输出<br>
枚举<br>
什么是枚举<br>
把一个事物所有可能的取值一一列举出来<br>
怎样使用枚举<br>
枚举的优缺点<br>
代码更安全<br>
书写麻烦<br>
位运算符：<br>
&amp;	——	按位与<br>
&amp;&amp;逻辑与 也叫并且<br>
&amp;&amp;与&amp; 的含义完全不同<br>
1&amp;1 = 1<br>
1&amp;0 = 0<br>
0&amp;1 = 0<br>
0&amp;0 = 0<br>
5&amp;7=5	21&amp;7=5<br>
5&amp;1=1	5&amp;10=0<br>
如果两个相应的二进制位都为1，则该位的结果值为1，否则为0<br>
|	——	按位或<br>
||逻辑或<br>
1|0 = 1<br>
1|1 = 1<br>
0|1 = 1<br>
0|0 = 0<br>
两个相应的二进制位中只要有一个为1，该位的结果值为1<br>
~	——	按位取反<br>
int i，k;<br>
k = ~i;等价于k = -(i+1)<br>
对一个二进制数按位取反，即将0变1，将1变0<br>
^	——	按位异或<br>
相同为0<br>
不同为1<br>
1^0=1<br>
0^1=1<br>
1^1=0<br>
0^0=1<br>
若参加运算的两个二进制位值相同则为0，否则为1<br>
&lt;&lt;	——按位左移<br>
i&lt;&lt;1表示把i的所有二进制左移一位<br>
左移n位相当于乘以2的n次方<br>
面试题：<br>
A）i = i*8;<br>
B）i = i&lt;&lt;3;<br>
请问上述两个语句，哪个语句执行的速度快<br>
答案：	B快</p>
<blockquote>
<blockquote>
<p>—— 按位右移<br>
i&gt;&gt;3表示把i的所有二进制位右移3位，左边一般是0，当然也可能补1<br>
右移n位相当于除2的n次方，前提是数据不能丢失<br>
面试题：<br>
A）i = i/8;<br>
B）i = i&gt;&gt;3;<br>
请问上述两个语句，哪个语句执行的速度快<br>
答案：	B快<br>
位运算的现实意义<br>
通过位运算符我们可以对数据的操作精确到每一位</p>
</blockquote>
</blockquote>
<p>进制转化[最重要]<br>
Image<br>
Image<br>
Image<br>
Image<br>
Image</p>
</li>
</ol>
<p>Image<br>
Image<br>
Image<br>
专题：<br>
补码：[次重要]<br>
原码<br>
也叫 符号-绝对值码<br>
最高位0表示正 1表示负，其余二进制位是该数字的绝对值的二			进制位</p>
<pre><code>		原码简单易懂
		加减运算复杂
		存在加减乘除四种运算，增加了CPU的复杂度
		零的表示不唯一
	反码
		反码运算不便，也没有在计算机中使用
	移码
		移码表示数值平移n位，n称为移码量
		移码主要用于浮点数的阶码的存储
	补码
		已知十进制求二进制
			求正整数的二进制
				除二取余，直至商为0，余数倒序排序
			求负整数的二进制
				先求该负数绝对值的二进制代码，然后将所有位					取反（1变成0,0变成1），末位加一，位数不够					时，左边补1
			求零的二进制
				全是0
	  	已知二进制求十进制
			如果首位是0，则表明是正整数，按普通方法来求
			如果首位是1，则表明是负整数
				将所有位取反，末尾加1，所得数字就是该负数					的绝对值
			全是0对应的十进制也是0
	学习目标：
		在VC++6.0中一个int类型的变量所能存储的数字范围是多少
			int类型变量所能存储的最大正数用十六进制表示是：										7FFFFFFF
			int类型变量所能存储的绝对值最大的负整数用十六进制									表示是：80000000
</code></pre>
<p>Image<br>
最小负数的二进制代码是多少<br>
最大正数的二进制代码是多少<br>
已知一个整数的二进制代码求出原始的数字<br>
数字超过最大正数会怎样</p>
<pre><code>字符串的处理
链表
	算法：
		通俗定义：
			解题的方法和步骤
		狭义定义：
			对数据存储的操作
	      对不同的存储结构，要完成某一个功能所执行的操作是不一样的
		比如：
			要输出数组中所有的元素的操作和
			要输出链表中所有元素的操作肯定是不一样的
		这说明：
			算法是依附于存储结构的
			不同的存储结构，所执行的算法是不一样的
		广义定义：
			广义的算法也叫泛型
			无论数据是如何存储的，对该数据的操作都是一样的
		我们至少可以通过两种结构来存储数据
			数组
				优点：
					存取速度快
				缺点：
					需要一个连续的很大的内存
					插入和删除的效率很低
			链表
				专业术语：
					首节点
						存放第一个有效数据的节点	
					尾节点
						存放最后一个有效数据的节点
					头结点
				头结点的数据类型和首节点的类型是一模一样的
				头结点是首节点前面的那个节点
				头结点并不存放有效数据
				设置头结点的目的是为了方便对链表的操作
					头指针
						存放头结点地址的指针变量
				优点：
					插入删除元素效率高
					不需要一个连续的很大的内存
				缺点：
					查找某个位置的效率低
</code></pre>
<p>二进制全部为零的含义 ——0000000000000 的含义<br>
1.数值零<br>
2.字符串结束标记符'\0'<br>
3.空指针NULL<br>
NULL本质也是零，而这个零不代表数字零，而表示的内存单元编号零<br>
我们计算机规定了，以零为编号的存储单元的内容不可读，不可写<br>
编译器提示：<br>
在不同编译器中，如果你发现你的C程序控制台敲完回车后迅速关闭，解决方法是引入一个头文件stdlib.h然后在主函数的return 0；前面加上system(“pause”);就可以使控制台不闪退</p>
<p>#include&lt;math.h&gt;<br>
pow(x,y)//x的y次幂</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://Token.github.io/post/hello-gridea/</id>
        <link href="https://Token.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>