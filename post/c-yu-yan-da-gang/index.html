<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>C语言大纲 | Gridea</title>
<link rel="shortcut icon" href="https://https://github.com/tang1201/Token.gothub.io.git/favicon.ico?v=1588041349499">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://https://github.com/tang1201/Token.gothub.io.git/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="C语言大纲 | Gridea - Atom Feed" href="https://https://github.com/tang1201/Token.gothub.io.git/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="C语言概述
1.为什么学习C语言
    1）.C的起源和发展（PPT）
    2）.C的特点
	优点
		代码量小	速度快		功能强大
	缺点
		危险性高
		开发周期长
		可移植性不强
3）.C的应用领域
4).C的重要性

2...." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://https://github.com/tang1201/Token.gothub.io.git">
  <img class="avatar" src="https://https://github.com/tang1201/Token.gothub.io.git/images/avatar.png?v=1588041349499" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              C语言大纲
            </h2>
            <div class="post-info">
              <span>
                2020-04-28
              </span>
              <span>
                31 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="c语言概述">C语言概述</h1>
<h2 id="1为什么学习c语言">1.为什么学习C语言</h2>
<pre><code>    1）.C的起源和发展（PPT）
    2）.C的特点
	优点
		代码量小	速度快		功能强大
	缺点
		危险性高
		开发周期长
		可移植性不强
3）.C的应用领域
4).C的重要性
</code></pre>
<p>2.怎样学习C语言<br>
3.学习的目标<br>
4.常见问题答疑<br>
1.学习Java为什么建议先学C语言<br>
2.没学过计算机专业课程能够学懂C语言<br>
3.英语和数学不好能学好C么？<br>
5.课程计划<br>
Image<br>
6.举例子:一元二次方程<br>
#include&lt;stdio.h&gt;<br>
#include&lt;math.h&gt;</p>
<p>int main(void)<br>
{<br>
int a = 1;<br>
int b = 5;<br>
int c = 6;<br>
double delta,x1,x2;<br>
delta = b<em>b - 4</em>a*c;</p>
<pre><code>if(delta &gt; 0)
{
	x1 = (-b + sqrt(delta))/(2*a);
	x2 = (-b - sqrt(delta))/(2*a);
	printf(&quot;该一元二次方程有两个解，x1 = %f,x2 = %f\n&quot;,x1,x2);
}
else if(delta == 0)
{
	x1 = (-b) / (2*a);
	x2 = x1;
	printf(&quot;该一元二次方程有一个唯一解，x1 = x2 = %f&quot;,x1,x2);
}
else
{
printf(&quot;无解\n&quot;);
}

return 0; 
</code></pre>
<p>}</p>
<p>C语言编程预备知识<br>
1.CPU 内存条 硬盘 显卡 主板 显示器 之间的关系<br>
2.helloword程序如何运行起来的<br>
3.什么是数据类型<br>
整数<br>
整型 —— int ——4<br>
短整型 —— short int ——2<br>
长整型 —— long int —— 8<br>
浮点数（实数）<br>
单精度浮点数 —— float —— 4<br>
双精度浮点数 —— double —— 8</p>
<pre><code>字符
	char——1
复合类型数据
	结构体
	枚举
	共用体
</code></pre>
<p>4.什么是变量<br>
变量的本质就是内存中一段存储空间<br>
5.CPU 内存条 VC++6.0 操作系统 之间的关系<br>
Image<br>
Image<br>
Image<br>
Image<br>
Image<br>
Image<br>
Image<br>
6.变量为什么必须初始化<br>
所谓初始化就是赋值的意思<br>
7.如何定义变量<br>
数据类型 变量名 = 要赋的值；<br>
等价于<br>
数据类型 变量名；<br>
变量名 = 要赋的值；<br>
举例子：<br>
int i = 3；	等价于	int i ；i = 3；<br>
int i，j；	等价于 inti；int j；<br>
int i，j=3	等价于 int i；int j；j=3；<br>
int i=3，j=5；等价于 int i；int j；i=3；j=5；<br>
int i，j；	i=j=5； 等价于 int i，j； i=5 j=5；<br>
8.什么是进制（PPT）<br>
十进制就是逢十进一<br>
二进制就是逢二进一<br>
9.常量在C语言中是如何表示的<br>
整数<br>
十进制：	传统的写法<br>
十六进制：	前面加Ox或OX<br>
八进制：	前面0	注意是数字0不是字母O<br>
浮点数<br>
传统的写法<br>
float x =3.2;//传统<br>
科学计数法<br>
float x = 3.2e3；	//x的值是 3200<br>
float x = 123.45e-2;	//x的值是1.2345<br>
字符<br>
单个字符用单引号括起来<br>
'A'表示字符A<br>
'AB'错误<br>
&quot;AB&quot;正确<br>
字符串用双引号括起来<br>
&quot;A&quot;正确，因为&quot;A&quot;代表了'A''\0'的组合<br>
10.常量以什么样的二进制代码储存在计算机中<br>
整数是以补码的形式转化为二进制代码存储在计算机中<br>
实数是以IEEE754标准转化为二进制代码存储在计算机中的<br>
字符的本质实际也是与整数的存储方式相同<br>
11.代码规范化<br>
代码的可读性更强[容易让自己和别人更容易看懂程序]<br>
降低代码出错的可能性<br>
12.什么是字节<br>
字节就是存储数据的单位，并且是硬件所能访问的最小单位<br>
1 字节 = 8 位<br>
1 K = 1024 字节<br>
1 M = 1024 K<br>
1 G = 1024 M<br>
13.不同类型数据之间相互赋值的问题<br>
(补码)<br>
int i = 45；<br>
long j = 102345；<br>
i = j；<br>
printf(&quot;%d %d\n&quot;,i,j);<br>
float x = 6.6;<br>
double y = 8.8;<br>
printf(&quot;%f %lf\n,x,y&quot;);<br>
int i = ;<br>
14.什么是ASCII<br>
ASCII不是一个值，而是一种规定，<br>
ASCII规定了不同的字符是使用哪个整数值去表示<br>
它规定了<br>
'A' —— 65<br>
'B' —— 66<br>
'a' —— 97<br>
'b' —— 98<br>
'0' —— 48<br>
15.字符的存储[字符本质上与整数的存储方式相同]<br>
基本的输入和输出函数的用法<br>
printf( )——将变量内容输出到显示器上<br>
四种用法<br>
1.printf(&quot;字符串&quot;)；<br>
2.printf(&quot;输出控制符&quot;，输出参数);<br>
3.printf(&quot;输出控制符1 输出控制符2 ……&quot;，输出参数1，输出参数			2……);输出控制符和输出参数的个数必须一一对应<br>
4.printf(&quot;输出控制符 非输出控制符&quot;，输出参数);<br>
输出控制符包含如下<br>
%d			——		int<br>
%ld			——		long int<br>
%c			——		char<br>
%f			——		float<br>
%lf			——		double						%x(或者%X或者%#X)	——	int或long int或short int<br>
%o			——		同上<br>
%s			——		字符串<br>
#include &lt;stdio.h&gt;<br>
int main(void)<br>
{<br>
int i = 1000;<br>
printf(&quot;%x\n&quot;,i);<br>
printf(&quot;%X\n&quot;,i);<br>
printf(&quot;%#x\n&quot;,i);<br>
printf(&quot;%#X&quot;,i);//最优<br>
return 0;																				<br>
}<br>
为什么需要输出控制符<br>
1. 01组成的代码可以表示数据也可表示指令<br>
2. 如果01组成的代码表示的是数据的话，那么同样的01代码组合以不同的输出格式输出就会有不同的输出结果</p>
<p>scanf( )【通过键盘将数据输入到变量中】<br>
用法一： scanf(&quot;输入控制符&quot;，输入参数)；<br>
功能：		将从键盘输入的字符转化为输入控制符所规定格式的数据，然			后存入以输入参数的值为地址的变量中<br>
用法二：	scanf(&quot;非输入控制符 输入控制符&quot;，输入参数)；<br>
功能：		将从键盘输入的字符转化为输入控制符所规定格式的数据，然			后存入以输入参数的值为地址的变量中<br>
非输入控制符必须原样输入<br>
如何使用scanf编写出高质量代码<br>
1. 使用scanf之前最好先使用printf提示用户以什么样的方式来输入<br>
2.scanf中尽量不要使用非输入控制符，尤其是不要用\n<br>
3.应该编写代码对用户的非法输入做适当的处理【非重点】<br>
while ((ch=getchar()) !='\n')<br>
continue;<br>
运算符<br>
算术运算符<br>
+ 	 - 	 * 	 /（除） 	 %（取余数）<br>
关系运算符<br>
&gt;	 &gt;= 	&lt; 	&lt;= 	!= 	==<br>
逻辑运算符<br>
！（非）	&amp;&amp;（并且）	||（或）<br>
C语言对真假的处理<br>
非零是真<br>
零是假<br>
真是1表示<br>
假是0表示<br>
&amp;&amp;左边的表达式为假 右边的表达式肯定不会执行<br>
||左边的表达式为真 右边的表达式肯定不会执行<br>
赋值运算符<br>
=	+=（a+=3;等价于a=a+3）	*=	 /=	 -=<br>
优先级别：<br>
算术 &gt; 关系 &gt; 逻辑 &gt; 赋值<br>
附录的一些琐碎的运算符知识<br>
自增	自减	三目运算符	逗号表达式<br>
自增[或者自减]<br>
分类：<br>
前自增 —— ++i<br>
后自增 —— i++<br>
前自增和后自增的异同<br>
相同：<br>
最终都使i的值加一<br>
不同：<br>
前自增整体表达式的值是i加1之后的值<br>
后自增整体表达式的值是i加1之前的值<br>
为什么会出现自增<br>
代码更精炼<br>
自增的速度更快<br>
学习自增要明白的几个问题<br>
1.我们编程时尽量避免使用前自增和后自增的差别<br>
2.i++ 和 ++i  单独成一个语句，不要把它作为一个完整复合语句的一			部分来使用（自增表达式最好不要作为一个更大的表达式的一			部分来使用）<br>
如：76<br>
int m = i++ + ++i + i + i++；//这样写不但是不规范的代码<br>
而且是不可移植的代码<br>
printf（&quot;%d %d %d&quot;,i++,++i,i）;//同上<br>
2.三目运算符？：<br>
格式：<br>
A ？ B ：C<br>
等价于<br>
IF（A）<br>
B；<br>
else<br>
C；<br>
3.逗号表达式<br>
格式：<br>
（A，B，C，D）<br>
功能：从左往右执行<br>
最终表达式的值是最后一项的值<br>
Image<br>
Image<br>
流程控制【学习C语言的第一个重点】<br>
1.什么是流程控制<br>
代码执行的顺序<br>
2.流程控制的分类<br>
顺序</p>
<pre><code>	选择
		定义
		    某些代码可能执行，也有可能不执行，有选择的执行某些代码
		分类
			IF
				1.IF最简单的用法
				格式：
					IF（表达式）
						语句
				功能：
					如果表达式为真，执行语句
					如果表达式为假，语句不执行
				2.IF的范围问题
				    1.
					IF（表达式）
						语句A；
						语句B；
					解释：IF默认只能控制语句A的执行或不执行
						IF无法控制语句B的执行或不执行
						或者讲：语句B一定会执行
				    2.
					IF（表达式）
					｛
						语句A；
						语句B；
					｝
					此时IF可以控制语句A和语句B
				由此可见：IF默认只能控制一个语句的执行或不执行
					    如果想控制多个语句的执行或不执行
					    就必须把这些语句用｛｝括起来
				3.IF...else...的用法
				4.IF...else...IF...else...的用法
				5.C语言对真假的处理
				6.IF举例——求分数等级
				7.IF的常见问题解析
</code></pre>
<p>ImageImageImage<br>
Image<br>
Image<br>
Image<br>
Image</p>
<p>学习C语言的方法：<br>
Image<br>
如果程序实在无法彻底理解，就将它背会</p>
<pre><code>			switch
				把电梯程序看懂就行了
</code></pre>
<p>Image<br>
Image</p>
<p>Image<br>
Image<br>
Image<br>
循环<br>
定义：<br>
某些代码会被重复执行<br>
分类<br>
for<br>
1.格式：<br>
for（1；2；3）<br>
语句A；<br>
2.执行的流程【重点】<br>
单个for循环的使用<br>
多个for循环的嵌套使用<br>
for（1；2；3）<br>
for（4；5；6）<br>
A；<br>
B;</p>
<pre><code>				3.范围问题，
					for也默认只控制一条语句
				4.举例
					1+2+3+……+100
					1+1/2+1/3+……+1/100
</code></pre>
<p>强制类型转换<br>
格式：<br>
（数据类型）（表达式）<br>
功能：<br>
把表达式的值强制转化为前面所执行的数据类型<br>
例子：<br>
（int）（4.5+2.2）最终值是 6<br>
（float）（5）	最终值是 5.000000<br>
浮点数的错存所带来的问题<br>
float和double都不能保证可以精确的存储一个小数<br>
举例：<br>
float i = 99.9;<br>
printf(&quot;%f\n&quot;,i);<br>
输出结果为：99.900002<br>
因为浮点数无法正确存储，所以就衍生出来的两个编程问题：<br>
有一个浮点型变量x，如何判断x的值是否为零<br>
if(|x-0.000001|&lt;=0.000001)<br>
是<br>
else<br>
不是<br>
为什么循环中更新的变量不能定义成浮点型</p>
<pre><code>			while
				1.执行顺序
					格式：
						while（表达式）
							语句；
				2.与for的相互比较
			for和while可以相互转换
			但for的逻辑性更强，更不容易出错，推荐多使用for
						for （1；2；3）
							A；
						等价于
						1；
						while（2）
						{
							A;
							3;
						}
				3.举例
				从键盘输入一个数字，如果该数字是回文数
				则返回yes，否则返回no
				4.什么时候使用while，什么时候使用for
					

			do……while
				格式：
</code></pre>
<p>do<br>
{<br>
……<br>
} while（表达式）；<br>
主要用于人机交互<br>
do……whille不等价于for和while<br>
break与continue<br>
break<br>
break如果用于循环是用来终止循环<br>
break如果用于switch，则是用于终止switch<br>
break不能直接用于IF，除非IF属于循环内部的一个子句<br>
例子：<br>
for(i=0;i&lt;3;++i)<br>
{<br>
if (3&gt;2)<br>
break;//break虽然是IF内部的语句，但break终止的却是外部的for循环<br>
printf(&quot;shuchu\n&quot;);<br>
}<br>
在多层循环中，break只能终止距离它最近的循环<br>
例子2：<br>
for(i=0; i&lt;3;++i)<br>
{<br>
for(j=1;j&lt;4;++j)<br>
break;//break只能终止距离它最近的循环<br>
printf(&quot;shuchu\n&quot;);<br>
}<br>
在多层switch中，break也只能终止距离它最近的switch<br>
continue<br>
用于跳过本次循环余下的语句，转去判断是否需要执行下次循环<br>
for<br>
Image<br>
清除输入正确后的非法字符，例如：123zxc经过下列程序后就会清除后面的zxc<br>
Image<br>
数组<br>
为什么需要数组<br>
为了解决大量同类型数据的存储和使用问题<br>
为了模拟现实世界<br>
数组的分类<br>
一维数组<br>
怎样定义一维数组<br>
为n个变量连续分配存储空间<br>
所有的变量的数据类型必须相同<br>
所有变量所占的字节大小必须相等<br>
例子：<br>
int a[5];<br>
一维数组名不代表数组中的所有元素<br>
一维数组名代表数组第一个元素的地址<br>
有关一维数组的操作<br>
初始化<br>
完全初始化<br>
int a[5] = {1,2,3,4,5};<br>
不完全初始化，未被初始化的元素默认为0<br>
int a[5] = {1,2,3};<br>
不初始化，所有元素是垃圾值<br>
int a[5]；<br>
清零<br>
int a[5]  = ｛0｝；<br>
错误写法：<br>
int a[5];<br>
a[5] = {1,2,3,4,5};//错误<br>
只有在定义数组的同时才能整体赋值<br>
其他情况下整体赋值都是错误的<br>
int a[5] = ｛1,2,3,4,5｝；<br>
a[5] = 100;//error<br>
因为没有a[5]这个元素，最大只有a[4]<br>
int a[5] = {1,2,3,4,5};<br>
int b[5];<br>
如果要把a数组中的值全部赋给b数组<br>
错误的写法：<br>
b = a;//error<br>
正确的写法<br>
for (i=0;i&lt;5;++i)<br>
b[i] = a[i];</p>
<pre><code>				赋值
				排序
				求最大/小值
				倒置
				查找
				插入
				删除
				
	二维数组
		int a[3][4];
	总共是12个元素，可以当作3行4列看待，这12个元素的名字依次是
		a[0][0] a[0][1] a[0][2] a[0][3]
		a[1][0] a[1][1] a[1][2] a[1][3]
		a[2][0] a[2][1] a[2][2] a[2][3]
		a[i][j] 表示第i+1行 第j+1列的元素
		int a[m][n];该二维数组右下角的元素只能是a[m-1][n-1]
		初始化
			int a[3][4] = ｛1,2,3,4,5,6,7,8,9,10,11,12｝；
			int a[3][4] = ｛
				｛1,  2,  3,  4｝，
				｛5,  6,  7,  8｝，
				｛9, 10, 11, 12｝
			｝；
		操作 
			输出二维数组内容

			对二维数组排序
			求每一行的最大值
			判断矩阵是否对称
			矩阵的相乘
		输出二维数组内容：
	多维数组
		是否存在多维数组
			不存在
			因为内存是线性一维的
			n维数组可以当作每个元素是n-1维数组的一维数组
				比如：
					int a[3][4]；
					该数组是含有3个元素的一维数组
					只不过每个元素都可以再分为4个小元素
					int a[3][4][5];
					该数组是含有3个元素的一维数组
					只不过每个元素都是四行五列的二维数组
</code></pre>
<p>函数【C语言的第二个重点】：<br>
为什么需要函数<br>
避免了重复性操作<br>
有利于程序的模块化<br>
什么叫函数<br>
逻辑上：能够完成特定功能的独立的代码块<br>
物理上：能够接收数据[也可以不接收数据]<br>
能够对接收的数据进行处理<br>
能够将数据处理的结果返回[也可以不返回]<br>
总结：函数是个工具，它是为了解决大量类似问题而设计的<br>
函数可以当作一个黑匣子<br>
如何定义函数<br>
函数的返回值	函数名（函数的形参列表）<br>
｛<br>
函数的执行体<br>
｝<br>
1.函数定义的本质是详细描述函数之所以能够实现某个功能的具体方法<br>
2.return 表达式；的含义：<br>
1&gt;终止被调函数，向主调函数返回表达式的值<br>
2&gt;如果表达式为空，则只终止函数，不向主调函数返回任何值<br>
3&gt;break是用来终止循环和switch的，return是用来终止函数的<br>
例子：<br>
void f（）<br>
｛<br>
return；//只终止函数，不向主调函数返回任何值</p>
<p>｝<br>
int f（）<br>
｛<br>
return 10；//第一：终止函数，第二：向主调函数返回10<br>
｝<br>
3.函数返回值的类型也称为函数的类型，因为如果函数名前面的返回值		和函数执行体中的 return 表达式；中表达式类型不同的话，则最终函		数返回值的类型以函数名前的返回值为准<br>
例子：<br>
int f()<br>
{<br>
return 10.5;//因为函数返回值的类型为int<br>
所以最终f返回的是10而不是10.5<br>
}</p>
<pre><code>函数的分类
	有参函数 和 无参函数
	有返回值 和 无返回值
	库函数   和 用户自定义函数
	值传递   和 地址传递函数
	普通函数 和 主函数（main函数）
			一个程序必须有且只能有一个主函数
			主函数可以调用普通函数 普通函数不能调用主函数
			普通函数可以相互调用
			主函数是程序的入口和出口
</code></pre>
<p>函数内部的变量只在本函数内使用<br>
注意的问题<br>
函数调用和函数定义的顺序<br>
如果函数调用写在了函数定义的前面，则必须加函数前置声明<br>
函数前置声明：<br>
1.告诉编译器即将可能出现的若干个字母代表的是一个函数<br>
2.告诉编译器即将可能出现的若干个字母所代表的函数的形				参和返回值的具体情况<br>
3.函数声明是一个语句，末尾必须加分号<br>
4.对库函数的声明是通过#include&lt;库函数所在的文件名.h&gt;				来实现的<br>
形参和实参<br>
个数相同	位置一一对应	数据类型必须相互兼容<br>
如何在软件开发中合理的设计函数来解决实际问题<br>
一个函数的功能尽量独立，单一<br>
多学习，多模仿牛人的代码<br>
函数是C语言的基本单位，类是Java，c#，c++的基本单位<br>
常用的系统函数<br>
double sqrt(double x);<br>
求x的平方根<br>
int abs(int x)<br>
求x的绝对值<br>
double fabs（double x）<br>
求x的绝对值<br>
专题：<br>
递归<br>
变量的作用域和存储方式<br>
按照作用域分：<br>
全局变量<br>
在所有函数外部定义的变量叫全局变量<br>
全局变量使用范围：从定义位置开始到整个程序结束<br>
局部变量<br>
在一个函数内部定义的变量或函数的形参都统称为局部变量<br>
void () f(int i)<br>
{<br>
int j = 20;<br>
}<br>
局部变量使用范围：只能在本函数内使用<br>
注意的问题：<br>
全局变量和局部变量命名冲突的问题<br>
在一个函数内部如果定义的局部变量的名字和全局变量				名字一样时，局部变量会屏蔽掉全局变量<br>
按变量的存储方式<br>
静态变量<br>
自动变量<br>
寄存器变量<br>
指针：<br>
指针的重要性：<br>
表示一些复杂的数据结构<br>
快速的传递数据，减少了内存的耗用【重点】<br>
使函数返回一个以上的值【重点】<br>
能直接访问硬件<br>
能够方便的处理字符串<br>
理解面向对象语言中引用的基础</p>
<pre><code>	总结：指针是C语言的灵魂
指针的定义
	地址
		内存单元的编号
		从零开始的非负整数
		范围：4G【0—4G—1】
	指针
		指针就是地址，地址就是指针
		指针变量就是存放内存单元编号的变量，或者说指针变量就是			存放地址的变量
		指针和指针变量是两个不同的概念 
		但是要注意，通常我们叙述时会把指针变量简称为指针，实际			它们的	含义并不一样
		指针的本质就是一个操作受限的非负整数 
指针的分类
	1.基本类型指针【重点】
		参见文件：E:\Users\HP\Desktop\学习\指针_2.cpp
		附注：
			*的含义
				1.乘法
				2.定义指针变量
				3.指针运算符
					  该运算符放在该已经定义好的指针变量的前面
				  如果p是一个已经定义好的指针变量
				  则*p表示以p的内容为地址的变量
		如何通过被调函数修改主调函数普通变量的值
			1.实参必须为该普通变量的地址
			2.形参必须为指针变量
			3.在被调函数中通过
				*形参名  = ...
			的方式就可以修改主调函数相关变量的值
	2.指针和数组
		指针和一维数组
			一维数组名
				一维数组名是个指针常量
				它存放的是一维数组第一个元素的地址
			下标和指针的关系
				如果p是个指针变量，则
					p[i] 永远等价于 *（p+i）
			确定一个一维数组需要几个参数【如果一个函数要处理					一个一维数组，则需要接收该数组的哪些信息】					需要两个元素：
					数组第一个元素的地址
					数组的长度
			指针变量的运算
			    指针变量不能相加 不能相乘 也不能相除 只能相减
				如果两个指针变量指向的是同一块连续空间中的					不同存储单元，则这两个指针变量才能相减
				int a[5];
				p = &amp;a[1];
				q = &amp;a[4];
				printf(&quot;p和q相差了%d个单元&quot;，q-p);
			一个指针变量到底占几个字节【非重点】
				预备知识：
					sizeof（数据类型）
				    功能：返回值就是该数据类型所占的字节数
				    例子：sizeof（int）=4 sizeof（char)=1 							sizeof(double)=8
				sizeof(变量名）
				功能：返回值是该变量所占的字节数
</code></pre>
<p>当操作数是指针时，sizeof依赖于编译器。<br>
例如Microsoft　C/C++7.0中，<br>
near类指针字节数为2，far、huge类指针字节数为4。<br>
一般Unix的指针字节数为4。<br>
假设p指向char类型变量（1个字节）<br>
假设q指向int类型变量（4个字节）<br>
假设r指向double类型变量（8个字节）<br>
p q r 本身所占的字节数是否一样？<br>
答案：所占字节数是一样的<br>
总结：<br>
无论一个指针变量指向指向哪种变量，该						指针变量本身只占4个字节<br>
#include &lt;stdio.h&gt;</p>
<p>int main(void)<br>
{<br>
char ch = 'A';<br>
int i = 99;<br>
double x = 66.6;<br>
char * p = &amp;ch;<br>
int * q = &amp;i;<br>
double *r = &amp;x;</p>
<pre><code>printf(&quot;%d %d %d\n&quot;,sizeof(p),sizeof(q),sizeof(r));
 
return 0;
</code></pre>
<p>}<br>
/*<br>
————————————————————————————————————<br>
在VC++6.0中编译结果是4 4 4<br>
在Dev-C++中编译结果是8 8 8<br>
————————————————————————————————————<br>
*/<br>
一个变量的地址是用该变量首字节的地址来表示</p>
<pre><code>		指针和二维数组
	3.指针和函数
	4.指针和结构体
	5.多级指针
</code></pre>
<p>专题:<br>
动态内存分配【重难点】<br>
传统数组的缺点：<br>
1.数组长度必须事先规定，且只能是常整数，不能是变量<br>
例子：<br>
int a[5];//OK<br>
int len = 5;int a[len];//error<br>
2.传统形式定义的数组，该数组的内存程序员无法手动释放<br>
数组一旦定义，系统为该数组分配的存储空间就会一直存在，			直到该函数运行完毕时，数组的空间才会被释放<br>
3.数组的长度一旦定义，其长度就不能再更改<br>
数组的长度不能在函数运行的过程中动态的扩充或缩小<br>
4.A函数定义的数组，在A函数运行期间可以被其他函数使用，<br>
但A函数运行完毕后，A函数中的数组将无法被其他函数使用<br>
传统方式定义的数组不能跨函数使用<br>
为什么需要动态分配内存<br>
动态数组很好的解决了传统数组的这4个缺陷<br>
传统数组也叫静态数组<br>
动态内存分配举例_动态数组的构造</p>
<pre><code>	静态内存和动态内存的比较
		静态内存由系统自动分配，由系统自动释放
		静态内存是在栈分配的
		动态内存是由程序员手动分配，手动释放
		动态内存是在堆分配的
	多级指针
		
	跨函数使用内存的问题
</code></pre>
<p>结构体<br>
为什么需要结构体<br>
为了表示一些复杂的事物，而普通的基本类型变量无法满足实际要求	什么叫结构体<br>
把一些基本类型数据组合在一起形成的一个新的复合数据类型就是结构体<br>
如何去定义一个结构体<br>
3种方式，推荐使用第一种<br>
//第一种方式 这只是定义了一个新的数据类型，并没有定义变量<br>
struct Student<br>
{<br>
int age;<br>
float score;<br>
char sex;<br>
};<br>
//第二种方式<br>
struct Student2<br>
{<br>
int age;<br>
float score;<br>
char sex;<br>
}st2;<br>
//第三种方式<br>
struct<br>
{<br>
int age;<br>
float score;<br>
char sex;<br>
}st3;	<br>
怎么去使用结构体变量<br>
赋值和初始化<br>
定义的同时可以整体赋初值<br>
如果定义完之后，则只能单个的赋初值<br>
如何取出结构体变量中的每一个成员【重点】<br>
1.结构体变量名.成员名<br>
2.指针变量名-&gt;成员名	（第二种方式更常用）<br>
指针变量名-&gt;成员名在计算机内部会被转化成（*指针变							量名）.成员名的方式来执行<br>
所以说这两种方式是等价的<br>
例子：<br>
struct Student<br>
{<br>
int age;<br>
float score;<br>
char sex;<br>
};</p>
<p>int main(void)<br>
{<br>
struct Student st = {80,66.6,'F'};//初始化	定义的同时赋初值<br>
struct Student * pst = &amp;st;//&amp;st不能改成st</p>
<pre><code>st.sge = 10;//第一种方式 
pst-&gt;age = 88;//第二种方式 
return 0;
</code></pre>
<p>}</p>
<ol>
<li>
<p>pst-&gt;age 在计算机内部会转化成（*pst）.age，这就是-&gt;的含义，是一种硬性规定<br>
2.所以 pst-&gt;age等价于（*pst）.age也等价于 st.age<br>
3.我们之所以知道pst-&gt;age等价于 st.age，是因为pst-&gt;age是被转化成了（*pst）.age来执行</p>
</li>
<li>
<p>pst-&gt;age 的含义；<br>
pst所指向的那个结构体变量中的age这个成员<br>
结构体变量和结构体变量指针作为函数参数传递的问题<br>
推荐使用结构体指针变量作为函数参数来传递<br>
结构体变量的运算<br>
结构体变量不能相加，不能相减，也不能相互乘除<br>
但结构体变量可以相互赋值<br>
举例<br>
动态构造存放学生信息的结构体数组<br>
动态构造一个数组，存放学生的信息<br>
然后按分数排序输出<br>
枚举<br>
什么是枚举<br>
把一个事物所有可能的取值一一列举出来<br>
怎样使用枚举<br>
枚举的优缺点<br>
代码更安全<br>
书写麻烦<br>
位运算符：<br>
&amp;	——	按位与<br>
&amp;&amp;逻辑与 也叫并且<br>
&amp;&amp;与&amp; 的含义完全不同<br>
1&amp;1 = 1<br>
1&amp;0 = 0<br>
0&amp;1 = 0<br>
0&amp;0 = 0<br>
5&amp;7=5	21&amp;7=5<br>
5&amp;1=1	5&amp;10=0<br>
如果两个相应的二进制位都为1，则该位的结果值为1，否则为0<br>
|	——	按位或<br>
||逻辑或<br>
1|0 = 1<br>
1|1 = 1<br>
0|1 = 1<br>
0|0 = 0<br>
两个相应的二进制位中只要有一个为1，该位的结果值为1<br>
~	——	按位取反<br>
int i，k;<br>
k = ~i;等价于k = -(i+1)<br>
对一个二进制数按位取反，即将0变1，将1变0<br>
^	——	按位异或<br>
相同为0<br>
不同为1<br>
1^0=1<br>
0^1=1<br>
1^1=0<br>
0^0=1<br>
若参加运算的两个二进制位值相同则为0，否则为1<br>
&lt;&lt;	——按位左移<br>
i&lt;&lt;1表示把i的所有二进制左移一位<br>
左移n位相当于乘以2的n次方<br>
面试题：<br>
A）i = i*8;<br>
B）i = i&lt;&lt;3;<br>
请问上述两个语句，哪个语句执行的速度快<br>
答案：	B快</p>
<blockquote>
<blockquote>
<p>—— 按位右移<br>
i&gt;&gt;3表示把i的所有二进制位右移3位，左边一般是0，当然也可能补1<br>
右移n位相当于除2的n次方，前提是数据不能丢失<br>
面试题：<br>
A）i = i/8;<br>
B）i = i&gt;&gt;3;<br>
请问上述两个语句，哪个语句执行的速度快<br>
答案：	B快<br>
位运算的现实意义<br>
通过位运算符我们可以对数据的操作精确到每一位</p>
</blockquote>
</blockquote>
<p>进制转化[最重要]<br>
Image<br>
Image<br>
Image<br>
Image<br>
Image</p>
</li>
</ol>
<p>Image<br>
Image<br>
Image<br>
专题：<br>
补码：[次重要]<br>
原码<br>
也叫 符号-绝对值码<br>
最高位0表示正 1表示负，其余二进制位是该数字的绝对值的二			进制位</p>
<pre><code>		原码简单易懂
		加减运算复杂
		存在加减乘除四种运算，增加了CPU的复杂度
		零的表示不唯一
	反码
		反码运算不便，也没有在计算机中使用
	移码
		移码表示数值平移n位，n称为移码量
		移码主要用于浮点数的阶码的存储
	补码
		已知十进制求二进制
			求正整数的二进制
				除二取余，直至商为0，余数倒序排序
			求负整数的二进制
				先求该负数绝对值的二进制代码，然后将所有位					取反（1变成0,0变成1），末位加一，位数不够					时，左边补1
			求零的二进制
				全是0
	  	已知二进制求十进制
			如果首位是0，则表明是正整数，按普通方法来求
			如果首位是1，则表明是负整数
				将所有位取反，末尾加1，所得数字就是该负数					的绝对值
			全是0对应的十进制也是0
	学习目标：
		在VC++6.0中一个int类型的变量所能存储的数字范围是多少
			int类型变量所能存储的最大正数用十六进制表示是：										7FFFFFFF
			int类型变量所能存储的绝对值最大的负整数用十六进制									表示是：80000000
</code></pre>
<p>Image<br>
最小负数的二进制代码是多少<br>
最大正数的二进制代码是多少<br>
已知一个整数的二进制代码求出原始的数字<br>
数字超过最大正数会怎样</p>
<pre><code>字符串的处理
链表
	算法：
		通俗定义：
			解题的方法和步骤
		狭义定义：
			对数据存储的操作
	      对不同的存储结构，要完成某一个功能所执行的操作是不一样的
		比如：
			要输出数组中所有的元素的操作和
			要输出链表中所有元素的操作肯定是不一样的
		这说明：
			算法是依附于存储结构的
			不同的存储结构，所执行的算法是不一样的
		广义定义：
			广义的算法也叫泛型
			无论数据是如何存储的，对该数据的操作都是一样的
		我们至少可以通过两种结构来存储数据
			数组
				优点：
					存取速度快
				缺点：
					需要一个连续的很大的内存
					插入和删除的效率很低
			链表
				专业术语：
					首节点
						存放第一个有效数据的节点	
					尾节点
						存放最后一个有效数据的节点
					头结点
				头结点的数据类型和首节点的类型是一模一样的
				头结点是首节点前面的那个节点
				头结点并不存放有效数据
				设置头结点的目的是为了方便对链表的操作
					头指针
						存放头结点地址的指针变量
				优点：
					插入删除元素效率高
					不需要一个连续的很大的内存
				缺点：
					查找某个位置的效率低
</code></pre>
<p>二进制全部为零的含义 ——0000000000000 的含义<br>
1.数值零<br>
2.字符串结束标记符'\0'<br>
3.空指针NULL<br>
NULL本质也是零，而这个零不代表数字零，而表示的内存单元编号零<br>
我们计算机规定了，以零为编号的存储单元的内容不可读，不可写<br>
编译器提示：<br>
在不同编译器中，如果你发现你的C程序控制台敲完回车后迅速关闭，解决方法是引入一个头文件stdlib.h然后在主函数的return 0；前面加上system(“pause”);就可以使控制台不闪退</p>
<p>#include&lt;math.h&gt;<br>
pow(x,y)//x的y次幂</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#c%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0">C语言概述</a>
<ul>
<li><a href="#1%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0c%E8%AF%AD%E8%A8%80">1.为什么学习C语言</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://https://github.com/tang1201/Token.gothub.io.git/post/hello-gridea/">
              <h3 class="post-title">
                Hello Gridea
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://https://github.com/tang1201/Token.gothub.io.git/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
